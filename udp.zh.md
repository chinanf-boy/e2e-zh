
# {{Paj.Toe}}

最简单的传输协议是将底层网络的主机到主机传递服务扩展为进程到进程通信服务. 在任何给定主机上都可能运行许多进程,因此协议需要添加解复用级别,从而允许每个主机上的多个应用程序进程共享网络. 除了这个需求之外,传输协议没有向底层网络提供的尽力而为的服务添加其他功能. 因特网的用户数据报协议是这种传输协议的一个例子. 

在这种协议中唯一有趣的问题是用于识别目标进程的地址的形式. 虽然过程是可能的*直接地*用一个OS分配的进程id (pid) 相互标识,这种方法仅在一个封闭的分布式系统中是可行的,在该系统中,单个OS在所有主机上运行,并为每个进程分配唯一的id. *间接地*使用抽象定位器来标识彼此,通常称为*港口*. 基本思想是让源进程向端口发送消息,让目标进程从端口接收消息. 

实现此解复用功能的端到端协议的报头通常包含消息的发送者 (源) 和接收者 (目的地) 的标识符 (端口) . 例如,在UDP报头中给出[图1](#udp-format). 请注意,UDP端口字段只有16位长. 这意味着有多达64K的可能端口,显然不足以识别Internet中所有主机上的所有进程. 幸运的是,端口不在整个Internet上进行解释,而只在单个主机上进行解释. 也就是说,进程是由某个特定的HOST-A (端口,主机) 对的端口来标识的. 事实上,这对构成UDP协议的解复用密钥. 

下一个问题是进程如何为要发送消息的进程学习端口. 通常,客户端进程启动与服务器进程的消息交换. 一旦客户端与服务器联系,服务器就知道客户端的端口 (从`SrcPrt`消息头中包含的字段,并可以对其进行回复. 因此,真正的问题是客户端首先如何学习服务器的端口. 一种常见的方法是让服务器接受消息. *著名港口*. 也就是说,每个服务器在广泛发布的某个固定端口接收其消息,这非常类似于美国在著名的电话号码911上提供的紧急电话服务. 例如,在因特网中,域名服务器(DNS)在每个主机上的众所周知的端口53接收消息,邮件服务在端口25监听消息,以及Unix`talk`程序在已知端口517接受消息,等等. 此映射定期在RFC中发布,并可在大多数UNIX系统中使用. `/etc/services`. 有时,一个众所周知的端口只是通信的起点: 客户机和服务器使用众所周知的端口来商定它们将用于后续通信的其他端口,从而使得这个众所周知的端口对其他客户机是免费的. 

<figure class="line">
	<a id="udp-format"></a>
	<img src="figures/f05-01-9780123850591.png" width="400px"/>
	<figcaption>Format for UDP header.</figcaption>
</figure>

另一种策略是概括这一思想,因此只有一个众所周知的港口. *端口映射器*服务接受消息. 客户端将向端口映射器的已知端口发送一条消息,请求它应该用来与"."服务通信的端口,并且端口映射器返回适当的端口. 这种策略使得随着时间推移可以容易地更改与不同服务相关联的端口,并且每个主机都可以为同一服务使用不同的端口. 

正如刚才提到的,端口纯粹是抽象的. 确切地说,它是如何实现的,从系统到系统,或者更确切地说,从OS到OS. 例如,在第1章中描述的Socket API是端口的一个示例实现. 通常,端口由消息队列实现,如图所示[图2](#udp-queue). 当消息到达时,协议 (例如,UDP) 将消息附加到队列的末尾. 如果队列已满,则丢弃该消息. 在UDP中没有流量控制机制来告诉发送方放慢速度. 当应用程序想要接收消息时,从队列的前部移除一个消息. 如果队列为空,则进程阻塞,直到消息可用. 

<figure class="line">
	<a id="udp-queue"></a>
	<img src="figures/f05-02-9780123850591.png" width="400px"/>
	<figcaption>UDP message queue.</figcaption>
</figure>

最后,尽管UDP没有实现流控制或可靠/有序的传递,但是除了将消息解复用到一些应用程序进程之外,它还提供了另一个功能ℴℴ它还通过使用校验和来确保消息的正确性.  (UDP校验和算法在IPv4中是可选的,但在IPv6中是强制性的. ) 基本的UDP校验和算法与用于IP的校验和算法相同,也就是说,它使用一个补算法来加一组16位的单词,并取结果的一个补. 但是,用于校验和的输入数据有点违反直觉. 

UDP校验和作为UDP报头的输入,消息体的内容,以及被称为*伪报头*. 伪报头由IP报头的三个字段组成-协议号ㄡ源IP地址和目标IP地址-加上UDP长度字段.  (是的,UDP长度字段在校验和计算中包括两次. ) 使用伪头背后的动机是验证此消息已经在正确的两个端点之间传递. 例如,如果在数据包传输期间修改了目的地IP地址,导致数据包被误传,则UDP校验和将检测到这一事实. 
